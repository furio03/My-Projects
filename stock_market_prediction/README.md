Files description top-down :

1) deploy_model.py : Deploy the best model and use it to make predictions on new datasets, so you don’t have to retrain the model each time. The deployment also preserves the best parameters found during training, such as the k in K-Means and other model-specific hyperparameters, making the model ready for immediate use. Finally,shows the hypothetical profits or losses that would have been obtained by following the signals generated by the model.

2) main.py : Trains a machine learning model on the available data using k-fold cross-validation (I used k=10). It supports multiple models, though XGBoost is recommended because it can handle many input variables without requiring strong assumptions about their significance.
If you choose to use another model, it is also possible to assign different weights to different types of errors. For example, you could assign a weight of 1 if the model classifies an instance as hold when it should be buy, and a weight of 10 if it classifies a sell as buy. This allows you to penalize the model more heavily for the types of errors you want to minimize.
Finally, the program saves the best-performing model, displays its performance on a test dataset, and shows the hypothetical profits or losses that would have been obtained by following the signals generated by the model.

3) optimize classification.py : The function in this file is used to make the results of the strategy comparable. It is unrealistic to assume that, if the strategy generates 100 consecutive buy signals, all positions could be opened, as capital is not infinite. Here, positions are limited to a maximum of 3 for both long and short trades, ensuring results are comparable with other strategies.

4) back_test.py: In this file, the model's predictions—'buy', 'sell', and 'hold'—are used to calculate the corresponding profit and loss, assuming that each action is executed at the market close, i.e., in the last available minute for trading. A 'buy' position is closed as soon as a 'sell' signal is generated, and vice versa.

5) forecasting.py : This function performs forecasting on a test dataset using a classification model with PyCaret. It sets up the training data with cross-validation, ignoring non-informative features such as Date, Close, and Volume.
The function automatically handles class weights if provided and creates a model that is then tuned using the F1-score to balance the trade-off between minimizing false positives and false negatives.
Performance is evaluated on both training and test datasets, providing accuracy and a full classification report. The function returns the predictions on the test set along with a metrics dictionary containing cross-validation metrics, train/test performance, and the tuned model object.

6) indicators.py : In this file, more informative variables for prediction are calculated starting from the only available variables: Volume, Date, and Close.

7) label.py : This file creates the target variable to be predicted by the model. The closing price is transformed into a 3-level categorical variable: 'buy', 'hold', and 'sell'.
The rule works as follows: for each row in the dataset, the current closing price is compared to the next day's closing price. If the price increases by at least a defined percentage threshold, the action is 'buy'. If the price decreases by at least the same threshold, the action is 'sell'. Otherwise, the action is 'hold'.

8) get_data.py : This function retrieves data from Yahoo Finance, accepts different timeframes, and only fetches the following variables: close, volume, and date.

9) analyze_performance.py : display the results in of the strategy

